// Generated by CoffeeScript 1.10.0

/*
  ColorFormatter:
  Used to transform a color into different color formats
  it also has the logic to display the color formatter dialog and some class methods to transform a MSColor
  to a color Dictionary that can be saved in a layer
 */
var ColorFormatter,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ColorFormatter = (function() {
  function ColorFormatter() {}

  ColorFormatter.prototype.FORMATS = [
    {
      id: "HEX",
      name: "HEX CSS",
      format: "colors.css"
    }, {
      id: "RGBA_CSS",
      name: "RGBA CSS",
      format: "colors.css"
    }, {
      id: "SASS",
      name: "SASS variables",
      format: "_colors.scss"
    }, {
      id: "UICOLOR_SWIFT",
      name: "UIColor (Swift)",
      format: "colors.swift"
    }, {
      id: "UICOLOR_OBJC",
      name: "UIColor (Objective-C)",
      format: "colors.m"
    }, {
      id: "ANDROID",
      name: "Android ARGB Color",
      format: "colors.java"
    }
  ];

  ColorFormatter.prototype.colorClassifier = new ColorClassifier();


  /*
    Shows the dialog to export the color dictionaries you provide
    returns a response code to know which button the user clicked.
   */

  ColorFormatter.prototype.showDialogWithColorDictionaries = function(colorDictionaries) {
    var accessory, alert, allColorsString, colorDictionary, filePath, fileString, format, i, len, lines, names, pasteboard, responseCode, savePanel, selection;
    names = this.FORMATS.map(function(enc) {
      return enc.name;
    });
    accessory = NSPopUpButton.alloc().initWithFrame_pullsDown(NSMakeRect(0, 0, 400, 25), false);
    accessory.addItemsWithTitles(names);
    accessory.selectItemAtIndex(0);
    alert = NSAlert.alloc().init();
    alert.setMessageText("Export colors");
    alert.setInformativeText("Select the color format:");
    alert.addButtonWithTitle('Save to file...');
    alert.addButtonWithTitle('Copy to clipboard');
    alert.addButtonWithTitle('Cancel');
    alert.setAccessoryView(accessory);
    responseCode = alert.runModal();
    selection = accessory.indexOfSelectedItem();
    lines = [];
    for (i = 0, len = colorDictionaries.length; i < len; i++) {
      colorDictionary = colorDictionaries[i];
      format = this.FORMATS[selection].id;
      lines.push(this.formatColorDictionary_withFormat_commented(colorDictionary, format, true));
    }
    allColorsString = lines.join("\n");
    switch (responseCode) {
      case 1000:
        log("Saving...");
        savePanel = NSSavePanel.savePanel();
        savePanel.setNameFieldStringValue(this.FORMATS[selection].format);
        savePanel.setAllowsOtherFileTypes(true);
        savePanel.setExtensionHidden(false);
        if (savePanel.runModal()) {
          filePath = savePanel.URL().path();
          fileString = NSString.stringWithString(allColorsString);
          fileString.writeToFile_atomically_encoding_error(filePath, true, NSUTF8StringEncoding, null);
        }
        break;
      case 1001:
        log("Copying...");
        pasteboard = NSPasteboard.generalPasteboard();
        pasteboard.declareTypes_owner([NSPasteboardTypeString], null);
        pasteboard.setString_forType(allColorsString, NSPasteboardTypeString);
    }
    return responseCode;
  };


  /*
    Takes a color dictionary and a format and returns a formatted string
    The commented flag is used to add comments (like when we export colors)
    or removing them (like when we are populating the cell layers with color data)
   */

  ColorFormatter.prototype.formatColorDictionary_withFormat_commented = function(colorDictionary, format, commented) {
    var formatIDs;
    formatIDs = this.FORMATS.map(function(enc) {
      return enc.id;
    });
    if (indexOf.call(formatIDs, format) >= 0) {
      return eval("this.format_" + format + "(colorDictionary, commented);");
    } else {
      return log("'" + format + "' format not implemented.");
    }
  };


  /*
    Takes a MSColor and a name or alias and packs it on a dictionary representation that can be then saved on a layer using the PluginCommand
   */

  ColorFormatter.colorToDictionary = function(color, name) {
    var dictionary;
    return dictionary = {
      name: name,
      hex: color.hexValue(),
      red: color.red(),
      blue: color.blue(),
      green: color.green(),
      alpha: color.alpha()
    };
  };


  /*
    Takes a the dictionary representation from above and returns a new MSColor instance
   */

  ColorFormatter.dictionaryToColor = function(dictionary) {
    var color;
    return color = MSColor.colorWithRed_green_blue_alpha(dictionary.red, dictionary.green, dictionary.blue, dictionary.alpha);
  };


  /*
  **************** FORMATS ****************
    HERE is when you have to do the implementation of the new format you want to add.
  
    all these methods must be prefixed with "format_" and then the format ID specified in he FORMATS constant
   */

  ColorFormatter.prototype.format_HEX = function(color, commented) {
    var formattedColor;
    formattedColor = '#' + color.hex;
    if (commented) {
      return formattedColor + "; /* " + color.name + " */";
    } else {
      return formattedColor;
    }
  };

  ColorFormatter.prototype.format_RGBA_CSS = function(color, commented) {
    var alpha, formattedColor;
    alpha = color.alpha < 1 ? color.alpha.toFixed(2) : color.alpha;
    formattedColor = "rgba(" + (Math.round(color.red * 255)) + "," + (Math.round(color.green * 255)) + "," + (Math.round(color.blue * 255)) + "," + alpha + ");";
    if (commented) {
      return formattedColor + " /* " + color.name + " */";
    } else {
      return formattedColor;
    }
  };

  ColorFormatter.prototype.format_ANDROID = function(color, commented) {
    var formattedColor;
    formattedColor = "Color.argb(" + (Math.round(color.alpha * 255)) + "," + (Math.round(color.red * 255)) + "," + (Math.round(color.green * 255)) + "," + (Math.round(color.blue * 255)) + ");";
    if (commented) {
      return formattedColor + " // " + color.name;
    } else {
      return formattedColor;
    }
  };

  ColorFormatter.prototype.format_SASS = function(color, commented) {
    var formattedColor, sassVariableName;
    formattedColor = '#' + color.hex;
    sassVariableName = '$' + color.name.toLowerCase().trim().split(" ").join("-");
    return sassVariableName + ": " + formattedColor + ";";
  };

  ColorFormatter.prototype.format_UICOLOR_SWIFT = function(color, commented) {
    var alpha, blue, formattedColor, green, red;
    red = Math.round(color.red * 100) / 100;
    green = Math.round(color.green * 100) / 100;
    blue = Math.round(color.blue * 100) / 100;
    alpha = Math.round(color.alpha * 100) / 100;
    formattedColor = "UIColor(red:" + red + ", green:" + green + ", blue:" + blue + ", alpha:" + alpha + ")";
    if (commented) {
      return formattedColor + " // " + color.name;
    } else {
      return formattedColor;
    }
  };

  ColorFormatter.prototype.format_UICOLOR_OBJC = function(color, commented) {
    var alpha, blue, formattedColor, green, red;
    red = Math.round(color.red * 100) / 100;
    green = Math.round(color.green * 100) / 100;
    blue = Math.round(color.blue * 100) / 100;
    alpha = Math.round(color.alpha * 100) / 100;
    formattedColor = "[UIColor colorWithRed:" + red + " green:" + green + " blue:" + blue + " alpha:" + alpha + "];";
    if (commented) {
      return formattedColor + " // " + color.name;
    } else {
      return formattedColor;
    }
  };

  return ColorFormatter;

})();
